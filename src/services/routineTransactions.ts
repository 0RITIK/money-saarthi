/**
 * Routine Transactions Service
 * Manages recurring income/expense scheduling with auto-execution logic.
 */

import { incomeApi, expenseApi, type ExpenseCategory } from "./api";

export type Frequency = "daily" | "weekly" | "monthly";

export interface RoutineTransaction {
  id: string;
  userId: string;
  type: "income" | "expense";
  amount: number;
  category: ExpenseCategory | string;
  description: string;
  frequency: Frequency;
  startDate: string; // ISO
  endDate?: string;  // ISO, optional
  isActive: boolean;
  lastExecutedDate?: string;
  createdAt: string;
  autoGenerated?: boolean;
}

export interface ExecutionResult {
  routineId: string;
  type: "income" | "expense";
  amount: number;
  description: string;
}

const STORE_KEY = "cfo_routine_transactions";
const generateId = () => Math.random().toString(36).substring(2, 11);

const getStore = (): RoutineTransaction[] => {
  try {
    return JSON.parse(localStorage.getItem(STORE_KEY) || "[]");
  } catch {
    return [];
  }
};

const setStore = (data: RoutineTransaction[]) => {
  localStorage.setItem(STORE_KEY, JSON.stringify(data));
};

/** Calculate the next execution date from the last executed date */
function getNextExecutionDate(lastDate: string, frequency: Frequency): Date {
  const d = new Date(lastDate);
  switch (frequency) {
    case "daily":
      d.setDate(d.getDate() + 1);
      break;
    case "weekly":
      d.setDate(d.getDate() + 7);
      break;
    case "monthly":
      d.setMonth(d.getMonth() + 1);
      break;
  }
  return d;
}

/** Get the next execution date for display */
export function getNextExecDateForRoutine(rt: RoutineTransaction): Date {
  if (!rt.lastExecutedDate) {
    return new Date(rt.startDate);
  }
  return getNextExecutionDate(rt.lastExecutedDate, rt.frequency);
}

/** Check if a date string matches today (YYYY-MM-DD comparison) */
function isSameDay(d1: Date, d2: Date): boolean {
  return d1.getFullYear() === d2.getFullYear() &&
    d1.getMonth() === d2.getMonth() &&
    d1.getDate() === d2.getDate();
}

export const routineApi = {
  getAll(userId: string): RoutineTransaction[] {
    return getStore().filter((r) => r.userId === userId);
  },

  create(userId: string, data: Omit<RoutineTransaction, "id" | "userId" | "createdAt" | "lastExecutedDate">): RoutineTransaction {
    const routines = getStore();
    const routine: RoutineTransaction = {
      ...data,
      id: generateId(),
      userId,
      createdAt: new Date().toISOString(),
    };
    routines.push(routine);
    setStore(routines);
    return routine;
  },

  update(id: string, updates: Partial<RoutineTransaction>): RoutineTransaction | null {
    const routines = getStore();
    const idx = routines.findIndex((r) => r.id === id);
    if (idx === -1) return null;
    routines[idx] = { ...routines[idx], ...updates };
    setStore(routines);
    return routines[idx];
  },

  delete(id: string): void {
    setStore(getStore().filter((r) => r.id !== id));
  },

  toggleActive(id: string): RoutineTransaction | null {
    const routines = getStore();
    const idx = routines.findIndex((r) => r.id === id);
    if (idx === -1) return null;
    routines[idx].isActive = !routines[idx].isActive;
    setStore(routines);
    return routines[idx];
  },

  /**
   * Execute all due routine transactions for a user.
   * Returns array of executed results for alert display.
   * Prevents duplicate execution for the same date.
   */
  async executedue(userId: string): Promise<ExecutionResult[]> {
    const routines = getStore();
    const userRoutines = routines.filter((r) => r.userId === userId && r.isActive);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const results: ExecutionResult[] = [];

    for (const rt of userRoutines) {
      // Check end date
      if (rt.endDate && new Date(rt.endDate) < today) {
        continue;
      }

      const startDate = new Date(rt.startDate);
      startDate.setHours(0, 0, 0, 0);
      if (startDate > today) continue; // Not started yet

      // Determine next execution date
      let nextExec: Date;
      if (!rt.lastExecutedDate) {
        nextExec = startDate;
      } else {
        nextExec = getNextExecutionDate(rt.lastExecutedDate, rt.frequency);
        nextExec.setHours(0, 0, 0, 0);
      }

      // Execute all due dates up to today (handles catching up missed days)
      while (nextExec <= today) {
        // Prevent duplicate: check if already executed for this date
        if (rt.lastExecutedDate && isSameDay(new Date(rt.lastExecutedDate), nextExec)) {
          nextExec = getNextExecutionDate(nextExec.toISOString(), rt.frequency);
          nextExec.setHours(0, 0, 0, 0);
          continue;
        }

        const dateStr = nextExec.toISOString().split("T")[0];

        if (rt.type === "income") {
          await incomeApi.add(userId, {
            amount: rt.amount,
            source: `${rt.description} [Auto]`,
            date: dateStr,
          });
        } else {
          await expenseApi.add(userId, {
            amount: rt.amount,
            category: rt.category as ExpenseCategory,
            description: `${rt.description} [Auto]`,
            date: dateStr,
          });
        }

        // Update lastExecutedDate
        const idx = routines.findIndex((r) => r.id === rt.id);
        if (idx !== -1) {
          routines[idx].lastExecutedDate = dateStr;
        }

        results.push({
          routineId: rt.id,
          type: rt.type,
          amount: rt.amount,
          description: rt.description,
        });

        // Move to next
        nextExec = getNextExecutionDate(dateStr, rt.frequency);
        nextExec.setHours(0, 0, 0, 0);
      }
    }

    setStore(routines);
    return results;
  },
};
